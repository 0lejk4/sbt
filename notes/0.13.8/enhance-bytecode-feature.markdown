  [1714]: https://github.com/sbt/sbt/issues/1714


### Fixes with compatibility implications

### Improvements

### Bytecode Enhancers

sbt 0.13.8 adds an extension point whereby users can effectively manipulate java bytecode (.class files) *before* the
incremental compiler attempts to cache the classfile hashes.  This allows libraries like ebean to function with sbt
without corrupting the compiler cache and rerunning compile every few seconds.

This splits the compile task into several subTasks:

1. `previousCompile`:  This task returns the previously persisted `Analysis` object for this project.
2. `compileIncremental`: This is the core logic of compiling Scala/Java files together.   This task actually does the
    work of compiling a project incrementally, including ensuring a minimum number of source files are compiled.
    After this method, all .class files that would be generated by scalac + javac will be available.
3. `manipulateByteCode`: This is a stub task which takes the `compileIncremental` result and returns it.
    Plugins which need to manipulate bytecode are expected to override this task with their own implementation, ensuring
    to call the previous behavior.
4. `compile`:  This task depends on `manipulateBytecode` and then persists the `Analysis` object containing all
    incremental compiler information.

Here's an example of how to hook the new `manipulateBytecode` key in your own plugin:

    manipulateBytecode in Compile := {
      val previous = (manipulateBytecode in Compile).value
      doManipulateBytecode(previous)  // Note: This must return a new Compiler.CompileResult with our changes.
    }

See [#1714][1714] for the full details of the implementation.

### Bug fixes
